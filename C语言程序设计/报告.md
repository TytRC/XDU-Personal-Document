

# 《程序设计基础课程设计》实验报告

姓名：陈德创

学号：19030500214

[toc]

# 一、有多少个三角形

## 1、题目描述

给定$N$个坐标点，求这些点可以组成多少个三角形。

## 2、算法描述

若不考虑共线的情况，即任意三个点都能构成三角形，那么显然可以构成$C_n^3$个三角形。

但是需要考虑共线。那么我们枚举所有三个点的组合，分别设为$(x_1,y_1),(x_2,y_2),(x_3,y_3)$，那么我们可以得到共线的条件为$\frac{y_2-y_1}{x_2-x_1}=\frac{y_3-y_2}{x_3-x_2}$，为了避免分式运算产生的浮点数精度问题，该分式可以化为$(y_2-y_1)(x_3-x_2)=(y_3-y_2)(x_2-x_1)$，这里我们假设输入的点都为整数点。

## 3、源程序

```c
#include<stdio.h>
#include<stdlib.h>

// 结构体存点
typedef struct POINT{
    int x, y;
}Point;
int ans;

int main(){
    int n;
    printf("请输入点的个数：");
    scanf("%d", &n);
    // poi为点集
    Point* poi = (Point*) calloc(n, sizeof(Point));
    for (int i = 0, x, y; i < n; i++){
        printf("请输入第%d个点的坐标：", i + 1);
        scanf("%d%d", &x, &y);
        (poi + i)->x = x;
        (poi + i)->y = y;
    }

    // 判断共线
    for (int i = 0; i < n; i++){
        // 第一个点
        int x1 = (poi + i)->x;
        int y1 = (poi + i)->y;
        for (int j = i + 1; j < n; j++){
            // 第二个点
            int x2 = (poi + j)->x;
            int y2 = (poi + j)->y;
            for (int k = j + 1; k < n; k++){
                // 第三个点
                int x3 = (poi + k)->x;
                int y3 = (poi + k)->y;
                // 防止溢出，用long
                long a = (y3 - y2) * (x2 - x1);
                long b = (y2 - y1) * (x3 - x2);
                // 如果不共线
                if (a != b) ans ++;
                else{
                    // 输入共线点
                    printf("共线点为：(%d,%d),(%d,%d),(%d,%d)\n", x1, y1, x2, y2, x3, y3);
                }
            }
        }
    }
    printf("一共可以组成 %d 个三角形", ans);
    return 0;
}
```

## 4、测试

### 测试数据

| 数据特征 | 1.无共线点、重点                          | 2.有共线点                                              | 3.有重点                                                     |
| -------- | ----------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 输入     | 5<br/>1 2<br/>1 3<br/>2 4<br/>7 8<br/>3 8 | 5<br/>1 2<br/>1 3<br/>2 4<br/>7 8<br/>3 6               | 5<br/>1 2<br/>1 2<br/>2 4<br/>7 8<br/>3 13                   |
| 输出     | 一共可以组成 10 个三角形                  | 共线点为：(1,2),(2,4),(3,6)<br/>一共可以组成 9 个三角形 | 共线点为：(1,2),(1,2),(2,4)<br/>共线点为：(1,2),(1,2),(7,8)<br/>共线点为：(1,2),(1,2),(3,13)<br/>一共可以组成 7 个三角形 |

### 结果

<img src="D:\Project\document\C语言程序设计\报告\image-20200603112135112.png" alt="image-20200603112135112" style="zoom:67%;" />

注意到第三个有一对重点，但是结果为7。这是因为我们将重点看成了两个在同一坐标的不同的点。当然我们也可以将其视为同一点，这样我们只需维护一个$has$数组即可。





# 二、高精度加减法

## 1、题目描述

实现大整数的加减法。

## 2、算法描述

高精度运算的整体思想就是模拟。我们考虑如下问题：

1. **数据的储存**
   显然我们要利用数组来进行数据的储存，比如$val[]$。数据可以分为两部分，数字部分和符号部分。我们可以用$val[0]$来表示符号，当$val[0]<0$时，这个数为负数，$val[0]>0$时为正数。我们将$0$视作正数。在运算时不可避免地要用到数组的长度，我们可以令$|val[0]|=val.length$。
   注意，我们令$val[1]$为数字的最低位，以此类推。

2. **数据的读入**
   注意到读入的数据不一定合法，我们在读入时要进行一定的判断。

3. **加减法的实现**
   注意到，我们加一个负数等于减一个正数，所以我们应当将符号和数字分开运算。对于数字部分，我们定义函数$int^*\ add(int^*\ x, int^*\ y),int^*\ minus(int^*\ x, int^*\ y)$，用来模拟加减法，具体模拟过程与小学手算差不多。要注意借位和进位。注意到减法的最高位可能为0，而加法可能导致和数组长度超过加数数组，所以最后都要进行判断，并重新整理答案。
   在加减法的过程中，两个数组长度可能不相同。我们默认$x.length>y.length$，若不，可以通过交换参数等来使其满足。对于$i\in (y.length,x.length)$，我们可以认为$y[i]=0$。

4. **程序整体框架**

   ```c
   // 用于输入数据
   int* input();
   // 用于输出数据
   void output(int* x);
   // 打印错误信息
   void print_error();
   // 加法实现
   int* add(int* x, int* y);
   // 用于判断两个数组的大小（不算符号）
   int cmp(int* x, int* y);
   // 减法实现
   int* minus(int* x, int* y);
   // 程序入口，完成程序的流程控制
   int main();
   ```



## 3、源程序

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<ctype.h>
const int MAXN = 1e5 + 5;

// 用于输入数据
int* input(){
    int* x;
    char* c = (char*) malloc(sizeof(char) * MAXN);
    int sig = 1;// 符号
    scanf("%s", c);
    int len = strlen(c);
    // 符号判断
    if (!isdigit(c[0])){
        if (c[0] == '-'){
            sig = -1;
            c++;
            len--;
        }
        else {
            free(c);
            return NULL;
        }
    }
    for (int i = 0; i < len; i++)
        if (!isdigit(c[i])){
            free(c);
            return NULL;
        }
            
    //为x分配内存空间，x[0]为符号和长度位,长度为数组长度
    x = (int*) malloc(sizeof(int) * (len + 1));
    x[0] = sig * (len + 1);
    for (int i = 0; i < len; i++){
        x[i + 1] = c[len - 1 - i] - '0';
    }
    return x;
}

// 用于输出数据
void output(int* x){
    int len = x[0];
    if (len < 0){
        printf("-");
        len *= -1;
    }
    for (int i = len - 1; i > 0; i--){
        printf("%d", x[i]);
    }
    printf("\n");
}

// 打印错误信息
void print_error(){
    printf("Input format error!");
}

// 加法实现
int* add(int* x, int* y){
    //保证len1不小于len2
    int len1 = abs(x[0]), len2 = abs(y[0]);
    if (len1 < len2){
        return add(y, x);
    }

    //为结果分配空间
    int* res = (int*)malloc(sizeof(int) * len1);
    res[0] = len1;
    int t = 0, i = 1;//t储存进位
    for (; i < len2; i++){
        t = x[i] + y[i] + t;
        res[i] = t % 10;//判断进位
        t /= 10;
    }
    for (; i < len1; i++){//把多出来的部分运算掉
        t += x[i];
        res[i] = t % 10;
        t /= 10;
    }
    
    // 结果整理
    if (t > 0) {//判断是否有进位
        res = realloc(res, (len1 + 1) * sizeof(int));
        res[len1] = t;
        ++res[0];
    }
    return res;
}

// 用于判断两个数组的大小（不算符号）
int cmp(int* x, int* y){
    int len1 = abs(x[0]), len2 = abs(y[0]);
    // 长度不等，比较长度
    if (len1 != len2)
        return len1 < len2 ? -1 : 1;
    // 长度相等，逐个比较
    for (int i = len1 - 1; i >= 1; i--){
        if (x[i] != y[i])
            return x[i] < y[i] ? -1 : 1;
    }
    return 0;
}

// 减法实现
int* minus(int* x, int* y){
    // 比较两数大小
    int p = cmp(x, y);
    int* res;
    if (p < 0){//保证len1不小于len2
        res = minus(y, x);
        res[0] *= -1;
        return res;
    }else if (p == 0){
        // 若两数相等
        res = (int*) malloc(sizeof(int) * 2);
        res[0] = 2;
        res[1] = 0;
        return res;
    }

    // 运算部分
    int len1 = abs(x[0]), len2 = abs(y[0]);
    res = (int*) malloc(sizeof(int) * len1);// 为结果分配空间
    int t = 0, i = 1;// t储存借位
    for (; i < len2; i++){
        t = x[i] - y[i] + 10 - t; //强制借位
        res[i] = t % 10;
        t = (t / 10) ^ 1; //1变0，0变1
    }
    for(; i < len1; i++){
        t = x[i] + 10 - t;
        res[i] = t % 10;
        t = (t / 10) ^ 1;
    }
    
    // 对结果的整理
    for (i--; res[i] == 0; i--);//去掉高位上多余的0
    res[0] = i + 1;
    res = realloc(res, res[0] * sizeof(int)); //重新分配内存
    return res;
}

// 程序入口，完成程序的流程控制
int main(){
    int* x, *y, *res;
    char c;

    // 数据输入
    printf("Please input x : ");
    x = input();
    if (x == NULL){
        print_error();
        return 0;
    }
    printf("Please input y : ");
    y = input();
    if (y == NULL){
        print_error();
        return 0;
    }
    fflush(stdin);

    // 运算符输入
    printf("Please choose operator ('+' & '-' is available.) : ");
    scanf("%c", &c);

    if (c == '-') y[0] *= -1; //化减法为加法
    else if (c != '+'){
        print_error();
        return 0;
    }

    //真正的运算部分，符号相同为加，否则为减
    if (x[0] * y[0] > 0) res = add(x, y);
    else res = minus(x, y);

    // 最后的符号判断，比如两个负数相加结果为负，但前面的程序没有判断
    // 这里有个优化，其实应该分情况讨论，但是讨论完发现这一个式子就可以
    res[0] *= (x[0] < 0 ? -1 : 1);
    
    // 答案输出
    printf("The result is :");
    output(res);
    
    // 释放空间
    free(x);free(y);free(res);
    return 0;
}
```



## 4、测试

### 测试数据

| 数据特征 | 正数加法                            | 正数减法                          | 负数加法                           | 负数减法                           |
| -------- | ----------------------------------- | --------------------------------- | ---------------------------------- | ---------------------------------- |
| 输入     | 132132132113123 45436467765657657 + | 405945854435 964676745473807657 - | -9413213213123 -7456765765657657 + | -9413213213123 -7456765765657657 - |
| 输出     | 45568599897770780                   | -964676339527953222               | -7466178978870780                  | 7447352552444534                   |



### 结果

<img src="D:\Project\document\C语言程序设计\报告\image-20200603130359849.png" alt="image-20200603130359849" style="zoom: 50%;" />

<img src="D:\Project\document\C语言程序设计\报告\image-20200603130453897.png" alt="image-20200603130453897" style="zoom:67%;" />



# 三、堆栈模拟

## 1、题目描述

模拟栈，实现弹栈入栈。

## 2、算法描述

栈算是一个基本的数据结构了，简单并且广泛运用。栈是一个$FIFO$的数据结构。栈模拟主要考虑一下问题：

1. **数据储存**
   使用双向链表储存。事实上，如果采用链表来储存，那么压栈、弹栈等操作和链表的加入结点、删除结点基本无异，只是少了位置的选择。在这种情况下，可以把栈看成阉割版的链表，我们把这称之为“封装”。即只把我们需要的操作而不是所有可能的操作暴露出来。增加是一种能力，而减少是一种智慧。

   - 定义一个结点结构体

     ```c
     typedef struct NODE{
         int x;
         struct NODE* next;
         struct NODE* before;
     }list;
     ```

   - 定义一个栈结构体
     里面有两个`node*`，分别为`head`和`now`，前者表示链表头，后者指向栈顶元素。显然，当`head==now`时，栈为空。

     ```c
     typedef struct STACK{
         node* head;
         node* now;
     }stack;
     
     stack* st;
     ```

     

2. **初始化**
   初始化过程可以包括：

   - 为`st`分配内存空间
   - 为`head`分配内存空间
   - 初始化`now`，令其等于`head`
   - `st->head->next = st->now;`
     `st->head->before = NULL;`

   

3. **压栈操作**
   压栈操作可分为如下几步：

   1. 新建`node`结点为`t`

   2. 更新此结点的`next`为`NULL`，`x`为压栈的数据，`before`为`now`

   3. `st->now->next = t;`
      `st->now = t;`
      这一步可能有些难以理解，是这样的，在这步操作之前，`st-now`指向的是原来的栈顶元素，现在压进了一个新的元素，显然原来栈顶元素的下一个元素就变成了`t`，而因为压进来了新元素，所以现在栈顶元素变成了`t`。

      

4. **弹栈操作**
   弹栈操作可以分为如下几步：

   1. 判断栈是否为空，若是，则打印信息并返回
   2. `st->now = st->now->before`，即令`now`为当前元素的下一个元素
   3. `free(st->now->next)`，即释放不再使用的空间
   4. 在上一步后，`st->now->next`仍指向原来的地址，现在我们应当令其为`NULL`

5. **流程控制**
   这没啥好说的，每次读入一个字符串然后判断操作就可以了。

## 3、源程序

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<ctype.h>

typedef struct NODE{
    int x;
    struct NODE* next;// 下一个元素，栈顶元素指向NULL
    struct NODE* before;// 上一个元素，head指向NULL
}node;

typedef struct STACK{
    node* head;// 头元素
    node* now;// 栈顶元素
}stack;

stack* st;

// 栈的初始化
void init(){
    st = (stack*) malloc(sizeof(stack)); //为st分配内存空间
    st->head = (node*) malloc(sizeof(node)); //为head分配内存空间
    st->now = st->head; // 空栈，所以now=head
    st->head->next = st->now; 
    st->head->before = NULL; 
}

// 判断是否为空
int isempty(){
    return st->now == st->head;
}

// 打印栈中元素
void print(){
    node* now = st->head->next;
    while (now != NULL){
        printf("%d ", now->x);
        now = now->next;
    }
    printf("\n");
}

// 压栈
void push(int x){
    // 新建结点
    node* t = (node*) malloc(sizeof(node));
    // 栈顶，所以next为NULL
    t->next = NULL;
    t->x = x;
    t->before = st->now;
    // 令原栈顶元素指向t
    st->now->next = t;
    // 更新栈顶元素为t
    st->now = t;
}

void pop(){
    // 判断空栈
    if (isempty()){
        printf("pop ERROR : the stack has been empty!");
        return;
    }
    // 回退结点
    st->now = st->now->before;
    // 释放空间
    free(st->now->next);
    // 栈顶元素next为NULL
    st->now->next = NULL;
}

int top(){
    return st->now->x;
}

int main(){
    // 初始化
    char c[100];// 储存输入
    int x;
    init();// 栈初始化

    // 打印帮助信息
    printf("栈模拟\n");
    printf("'push x' ：将x压栈\n");
    printf("'pop'    ：弹出栈顶元素\n");
    printf("'top'    ：显示栈顶元素\n");
    printf("'quit'   ：退出\n");

    // 读入数据直到输入结束
    while (~scanf("%s", c)){
        // 压栈
        if (strcmp(c, "push") == 0){
            // 一次可以压入多个元素，直到输入非数字
            while (scanf("%d", &x)){
                push(x);
            }
            print();
            fflush(stdin);
        
        // 弹栈
        }else if (strcmp(c, "pop") == 0){
            pop();
            print();
            fflush(stdin);
        
        // 返回栈顶元素
        }else if (strcmp(c, "top") == 0){
            if (isempty())
                printf("top ERROR : the stack is empty now!");
            else{
                printf("%d\n", top());
                fflush(stdin);
            }

        // 退出
        }else if (strcmp(c, "quit") == 0)
            break;
        
        // 错误信息
        else printf("Input format error!\n");
    }
    return 0;
}
```



## 4、测试

### 测试数据

| 数据                 | 意图                 | 结果                                  |
| -------------------- | -------------------- | ------------------------------------- |
| top                  | 测试空栈top          | top ERROR : the stack is empty now!   |
| pop                  | 测试空栈pop          | pop ERROR : the stack has been empty! |
| push 1 2 3 4 5 8 9 z | 测试压栈功能         | 1 2 3 4 5 8 9                         |
| pop                  | 测试弹栈功能         | 1 2 3 4 5 8                           |
| push 4 3 4 3 2 z     | 测试多次压栈弹栈操作 | 1 2 3 4 5 8 4 3 4 3 2                 |
| pop                  |                      | 1 2 3 4 5 8 4 3 4 3                   |
| pop                  |                      | 1 2 3 4 5 8 4 3 4                     |
| eareewr              | 测试错误输入         | Input format error!                   |
| quit                 | 结束                 |                                       |

### 结果

<img src="D:\Project\document\C语言程序设计\报告\image-20200603173043073.png" alt="image-20200603173043073" style="zoom:67%;" />



# 四、位图缩放

## 1、题目描述

编写一个程序，可以在命令行输入参数，完成指定位图的缩放，并存储到新文件。

## 2、算法描述

位图的缩放本质上为坐标的映射，即原图像到新图像像素的对应。考虑最简单的对应关系，假设原像素坐标为$(x,y)$，缩放倍率为$rx,ry$，那么显然新图像对应像素的坐标为$(x\times rx, y\times ry)$。主要代码如下：

```c
/*
tarHeight:目标图象高度
tarLinewidth:目标图象一行所占用的字节数
height:原图像高度
linewidth:原图像一行所占用的字节数
tarsrc:目标图像的数据数组
src:原图像的数据数组
*/
// 有些地方可能没有被映射，填充为白色
for (int i = 0; i < tarHeight; i++)
        for (int j = 0; j < tarLinewidth; j++)
            *(tarSrc + i * tarLinewidth + j) = 0xff;//对于24位位图，0xffffff代表白色
    
// 信息映射
for (int i = 0; i < height; i++){
    for (int j = 0; j < linewidth; j += 3){ // 对每个像素处理，每个像素占三字节
        ul x = i * linewidth + j;	// 原坐标
        ul y = (ul)floor(i * rh) * tarLinewidth + floor(j * rw);	// 新坐标
        for (int k = 0; k < 3; k++)
            tarSrc[y + k] = src[x + k];
    }
}
```

效果如下：

<img src="D:\Project\document\C语言程序设计\报告\image-20200610173714658.png" alt="image-20200610173714658" style="zoom: 33%;" />

图为长宽均放大$1.5$ 倍的效果，可以发现新图像有着明显的栅栏效果，这是因为放大新图像有些像素是没有原像导致的。如果我们将新图像未被映射的地方标记为黑色，效果更加明显。如下图：

<img src="D:\Project\document\C语言程序设计\报告\image-20200610173936032.png" alt="image-20200610173936032" style="zoom: 33%;" />

<img src="D:\Project\document\C语言程序设计\报告\image-20200610174023200.png" alt="image-20200610174023200" style="zoom: 33%;" />



为了解决这种情况，我们可以考虑对图中黑线的地方进行处理。处理方法为插值。也就是从临近的像素块获得信息，人为构造这一像素块。最容易想到和实现的算法就是线性插值了吧。（参考自：https://blog.csdn.net/fengxianghui01/article/details/84891388）

<img src="D:\Project\document\C语言程序设计\报告\20181209121145389.jpg" alt="img" style="zoom:50%;" />

如图所示，假设新图像的某一像素被映射到$P$点了，但是$P$点不是一个整数点，那么我们可以考虑从其周围的4个整数点中获得信息，来构造这一点的情况。我们假设像素的变化是线性的。设$f(P)$为$P$点的像素情况，那么我们可以得到：

$f(R_1) \approx \frac{x_2-x}{x_2-x_1}f(Q_{11}) + \frac{x-x_1}{x_2-x_1}f(Q_{21}) $

$f(R_2) \approx \frac{x_2-x}{x_2-x_1}f(Q_{12}) + \frac{x-x_1}{x_2-x_1}f(Q_{22}) $

$f(P) \approx \frac{y_2-y}{y_2-y_1}f(R_1) + \frac{y-y_1}{y_2-y_1}f(R_2) $

由此，我们得到了$P$点像素的近似值。可以依靠一下程序求得：

```c
int x1, x2, y1, y2, Fq11, Fq12, Fq21, Fq22, Fp;
double x, y, Fr1, Fr2;
for (int i = 0; i < tarHeight - 1; ++i){
    for (int j = 0; j < tarLinewidth; ++j){
        x = 1 / rw * j; // 原图像坐标
        y = 1 / rh * i;

        x1 = floor(x); x2 = x1 + 1;
        y1 = floor(y); y2 = y1 + 1;
        // 四个坐标对应的灰度值
        Fq11 = *(src + y1*linewidth + x1);
        Fq12 = *(src + y2*linewidth + x1);
        Fq21 = *(src + y1*linewidth + x2);
        Fq22 = *(src + y2*linewidth + x2);

        // x方向
        Fr1 = 0; Fr2 = 0;
        Fr1 = (x2 - x) / (x2 - x1)*Fq11 + (x - x1) / (x2 - x1)*Fq21;
        Fr2 = (x2 - x) / (x2 - x1)*Fq12 + (x - x1) / (x2 - x1)*Fq22;
        // y方向
        Fp = (y2 - y) / (y2 - y1)*Fr1 + (y - y1) / (y2 - y1)*Fr2;
        if (Fp >= 0 && Fp <= 255)
            tarSrc[i * tarLinewidth + j] = Fp;
    }
}
```

## 3、源程序

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#pragma pack(1)  /* 必须在结构体定义之前使用,这是为了让结构体中各成员按1字节对齐*/
typedef unsigned long ul;
typedef unsigned char uc;
/*-------- 以下来源自https://blog.csdn.net/JTang_TYX/article/details/78940234 ----------*/

typedef struct tagBITMAPFILEHEADER{
    unsigned short bfType;      //保存图片类型。 'BM'
    unsigned long  bfSize;      //位图文件的大小，以字节为单位（3-6字节，低位在前）
    unsigned short bfReserved1;//位图文件保留字，必须为0(7-8字节）
    unsigned short bfReserved2;//位图文件保留字，必须为0(9-10字节）
    unsigned long  bfOffBits;  //RGB数据偏移地址,位图数据的起始位置，以相对于位图（11-14字节，低位在前）
}HEAD;

typedef struct tagBITMAPINFOHEADER{
    unsigned long  biSize;      //本结构所占用字节数（15-18字节）
    unsigned long  biWidth;     //位图的宽度，以像素为单位（19-22字节）
    unsigned long  biHeight;    //位图的高度，以像素为单位（23-26字节）
    unsigned short biPlanes;    //目标设备的级别，必须为1(27-28字节）
    unsigned short biBitCount;  //每个像素所需的位数，必须是1（双色）（29-30字节）,4(16色），8(256色）16(高彩色)或24（真彩色）之一
    unsigned long  biCompression;//位图压缩类型，必须是0（不压缩），（31-34字节）
    //1(BI_RLE8压缩类型）或2(BI_RLE4压缩类型）之一
    unsigned long  biSizeImage;  //位图的大小(其中包含了为了补齐行数是4的倍数而添加的空字节)，以字节为单位（35-38字节）
    unsigned long  biXPelsPerMeter;//位图水平分辨率，每米像素数（39-42字节）
    unsigned long  biYPelsPerMeter;//位图垂直分辨率，每米像素数（43-46字节)
    unsigned long  biClrUsed;      //位图实际使用的颜色表中的颜色数（47-50字节）
    unsigned long  biClrImportant; //位图显示过程中重要的颜色数（51-54字节）
}INFO;

/*-------- 以上来源自https://blog.csdn.net/JTang_TYX/article/details/78940234 ----------*/


int execute(char* in_name, char* out_name, double rw, double rh){
    // 打开文件
    FILE *in = fopen(in_name, "rb");
    FILE *out = fopen(out_name, "wb");
    if (in == NULL || out == NULL)
        return -1;

    // 读入文件头
    HEAD* fileHead = (HEAD*)malloc(sizeof(HEAD));
    INFO* infoHead = (INFO*)malloc(sizeof(INFO));
    fread(fileHead, sizeof(HEAD), 1, in);
    fread(infoHead, sizeof(INFO), 1, in);
    
    // 获得所需信息并读入图片信息
    ul width = infoHead->biWidth;
    ul height = infoHead->biHeight;
    ul linewidth = width * 3;
    ul size = linewidth * height;
    uc* src = (uc*) malloc(size);
    fread(src, size, 1, in);
    printf("%ld %ld\n", width, height);

    // 获得放缩后的信息并写入
    ul tarWidth = ceil(width * rw);
    ul tarHeight = ceil(height * rh);
    ul tarLinewidth = tarWidth * 3;
    ul tarSize = tarHeight * tarLinewidth;
    uc* tarSrc = (uc*) malloc(tarSize);

    fileHead->bfSize = 54 + tarSize;
    infoHead->biWidth = tarWidth;
    infoHead->biHeight = tarHeight;
    
    fwrite(fileHead, sizeof(HEAD), 1, out);
    fwrite(infoHead, sizeof(INFO), 1, out);
    printf("%ld %ld\n", tarWidth, tarHeight);
    fflush(out);
    /* 普通映射法 */
    // for (int i = 0; i < tarHeight; i++)
    //     for (int j = 0; j < tarLinewidth; j++)
    //         *(tarSrc + i * tarLinewidth + j) = 0xff;//对于24位位图，0xffffff代表白色
    
    // // 信息映射
    // for (int i = 0; i < height; i++){
    //     for (int j = 0; j < linewidth; j += 3){ // 对每个像素处理，每个像素占三字节
    //         ul x = i * linewidth + j;	// 原坐标
    //         ul y = (ul)floor(i * rh) * tarLinewidth + floor(j * rw);	// 新坐标
    //         for (int k = 0; k < 3; k++)
    //             tarSrc[y + k] = src[x + k];
    //     }
	// }

    /*双线性插值法*/
    int x1, x2, y1, y2, Fq11, Fq12, Fq21, Fq22, Fp;
	double x, y, Fr1, Fr2;
	for (int i = 0; i < tarHeight - 1; ++i){
		for (int j = 0; j < tarLinewidth; ++j){
			x = 1 / rw * j; // 原图像坐标
			y = 1 / rh * i;

			x1 = floor(x); x2 = x1 + 1;
			y1 = floor(y); y2 = y1 + 1;
			// 四个坐标对应的灰度值
			Fq11 = *(src + y1*linewidth + x1);
			Fq12 = *(src + y2*linewidth + x1);
			Fq21 = *(src + y1*linewidth + x2);
			Fq22 = *(src + y2*linewidth + x2);

            // x方向
			Fr1 = 0; Fr2 = 0;
			Fr1 = (x2 - x) / (x2 - x1)*Fq11 + (x - x1) / (x2 - x1)*Fq21;
			Fr2 = (x2 - x) / (x2 - x1)*Fq12 + (x - x1) / (x2 - x1)*Fq22;
            // y方向
			Fp = (y2 - y) / (y2 - y1)*Fr1 + (y - y1) / (y2 - y1)*Fr2;
			if (Fp >= 0 && Fp <= 255)
				tarSrc[i * tarLinewidth + j] = Fp;
		}
	}
    fwrite(tarSrc, 1, tarSize, out);
    fclose(out);
    fclose(in);
    return 0;
}


int main(int argc, char* argv[]){
    if (argc != 5){
        printf("Input format ERROR!\n");
        printf("no4.c old_file.bmp new_file.bmp rate_of_width rate_of_height");
        return 0;
    }
    int rw = atoi(argv[3]), rh = atoi(argv[4]);
    int x = execute(argv[1], argv[2], rw, rh);
    if (x == -1) printf("Files NOT Found!");
    if (x == 0) printf("Succeed!");
    return 0; 
}


```

## 4、测试

<img src="D:\Project\document\C语言程序设计\报告\image-20200610181439426.png" alt="image-20200610181439426" style="zoom:33%;" />

效果不是很好，整体亮度暗了很多，但是不知道哪里出了问题。

# 五、RLE压缩解压算法

## 1、题目描述

命令行输入参数，完成指定文件的压缩解压。

## 2、算法描述

RLE是一种简单朴素的压缩算法（在我目前看来是这样的），它的思想非常简单——将多个连续相同的数据合并。我们从字节的角度考虑，如果一个文件在某一处有着重复的字节，比如`x x x x x x`，那么我我们可以通过`6 x`来储存这样一串数据。那么对于非重复字节呢？比如`y z t `，我们可以这样储存`1 y 1 z 1 t`，但是这样可能会导致数据膨胀，得不偿失。所以我们可以考虑将一连串不重复的数据综合考虑，即考虑如下储存`3 y x t`，这样就可以简化非重复字节的。也就是说，我们真正储存的内如分为两部分，一部分是计数字节，一部分是数据字节。

那么我们如何区分连续非连续字节呢？对于计数字节，我们可以将其最高位标志为重复、非重复。当计数字节最高位为1时，代表着原数据为重复数据，当计数字节最高位为0的时候，代表原数据为非重复的。这样，我们一个计数字节能表示的最高数字为`127`。

在实际过程中，将重复三个的字节视作重复字节，如果只重复两个，将其视为非重复字节。据说这样效果会好一些。但是其实这个算法的简单应就注定了其只能在某些特定情况下效果良好。很多时候这个算法适得其反。

这样我们在解压时也十分方便，读入一个计数字节，判断其后跟随的是重复还是非重复数据。如果是重复数据，则再次输入一个字节，并输出`n`次；如果是非重复的，则再次输入`n`个字节，并直接输出。`n`为计数字节所代表的数量。如此往复，直到文件结束。

## 3、源程序

代码很长，但是其实逻辑不难理解。

这里我的解压操作直接写到了`execute`函数里面，按照我参考的博客的思路，应当但写一个函数。但是这样会有问题，一是解压时的`outbuf`要开的很大，应当为`inbuf`的64倍左右。另一方面，这样可能导致非重复字节的截断，导致解压错误。（我就这样debug了一晚上加一上午，累死我也）

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef unsigned char uc;
const uc REPEAT = 0x80; // 1000 0000 
const uc FOR_COUNT = 0x7f; // 0111 1111
const int MAX_LEN = 0x7f;

// 判断其后是重复的还是非重复的
int isRepeated(uc* buf, int size){
    // 如果还剩加不到三个，则视为非重复
    if (size < 3) return 0;
    if ((buf[0] == buf[1]) && (buf[1] == buf[2]))
        return 1;
    return 0;
}

// 获得后面重复字节的个数
int getRepeatedLen(uc* buf, int size){
    int tar = buf[0];
    int len = 1;
    while (len < size && len < MAX_LEN && buf[len] == tar) ++len;
    return len;
}

// 获得后面非重复字节的个数
int getNonrepeatedLen(uc* buf, int size){
    if (size < 3) return size;
    int len = 2;
    int a = buf[0], b = buf[1]; // a，b储存当前判断字节的前两个字节
    while (len < size && len < MAX_LEN && ((a != b) || (b != buf[len]))){
        a = b;
        b = buf[len];
        ++len;
    }
    return len;
}

// 压缩程序
int RLE_Encode(uc* inbuf, int insize, uc* outbuf, int outsize){
    uc* src = inbuf;    // 输入指针
    int inleft = insize; // 剩余数组元素个数
    int count = 0; // count表示数量， tmp临时变量
    int out_poi = 0;    //输出数组下标

    // inleft == 0 时代表输入结束
    while (inleft > 0){
        //如果是重复的
        if (isRepeated(src, inleft)){
            // 缓存数组设置太小了
            if (out_poi + 2 > outsize) return -1;
            // 得到重复的个数
            count = getRepeatedLen(src, inleft);
            //写入输出数组
            outbuf[out_poi++] = count | REPEAT;
            outbuf[out_poi++] = *src;
            // 移动输入数组指针
            src += count;
        }else{
            // 得到不重复的个数
            count = getNonrepeatedLen(src, inleft);
            // 缓存数组设置太小了
            if (out_poi + count >= outsize) return -1;
            outbuf[out_poi++] = count;
            //逐个写入
            for (int i = 0; i < count; i++)
                outbuf[out_poi++] = *src++;
        }
        inleft -= count;
    }
    return out_poi;   
}

// 执行主程序
int execute(char* in_name, char* out_name, int ty){
    FILE *in = fopen(in_name, "rb");
    FILE *out = fopen(out_name, "wb");
    // 打开文件失败
    if (in == NULL || out == NULL)
        return -1;
    
    // 为输入缓冲、输入缓冲分配内存空间
    uc *inbuf, *outbuf;
    inbuf = (uc*) malloc((sizeof(uc)) * 1024);
    outbuf = (uc*) malloc((sizeof(uc)) * 2048);

    size_t len;
    // ty == 0 时为压缩
    if (ty == 0){
        // 每次读入1024字节
        while ((len = fread(inbuf, sizeof(uc), 1024, in)) != 0){
            // 执行压缩操作
            int tmp = RLE_Encode(inbuf, len, outbuf, 2048);
            // 写入输出文件
            fwrite(outbuf, sizeof(uc), tmp, out);
        }
        // 解压操作
    }else {
        // 读入一个字节
         while (fread(inbuf, sizeof(uc), 1, in)){
             // 获得个数
            int count = (*inbuf) & FOR_COUNT;
            // 如果是重复的
            if ((*inbuf) & REPEAT){
                // 再读入一个字节
                fread(inbuf, sizeof(uc), 1, in);
                // 输出count次
                for (int i = 0; i < count; i++)
                    outbuf[i] = *inbuf;
            // 如果是不重复的
            }else{
                // 再读入count个
                fread(inbuf, sizeof(uc), count, in);
                // 依次输出
                for (int i = 0; i < count; i++)
                    outbuf[i] = inbuf[i];
                
            }
            // 输出
            fwrite(outbuf, sizeof(uc), count, out);
        }
    }
    fclose(in);
    fclose(out);
    return 0;
}

int main(int argc, char* argv[]){
    // 参数错误预判断
    if (argc != 4){
        printf("Input format ERROR!");
        return 0;
    }

    // 判断操作
    int ty;
    if (strcmp(argv[2], "-c") == 0) ty = 0;
    else if (strcmp(argv[2], "-d") == 0) ty = 1;
    else {
        printf("Input format ERROR! -- 2");
        return 0;
    }
    
    int t = execute(argv[1], argv[3], ty);
    if (t == -1){
        printf("File not found!\n");
    }else{
        printf("Succeed!\n");
    }
    return 0;
}
```

## 4、测试

原图片：

<img src="D:\Project\document\C语言程序设计\报告\image-20200603231725878.png" alt="image-20200603231725878" style="zoom:67%;" />

命令：

<img src="D:\Project\document\C语言程序设计\报告\image-20200603232120213.png" alt="image-20200603232120213" style="zoom:67%;" />

结果对比：

<img src="D:\Project\document\C语言程序设计\报告\image-20200603231936003.png" alt="image-20200603231936003" style="zoom:67%;" />

<img src="D:\Project\document\C语言程序设计\报告\image-20200603232054967.png" alt="image-20200603232054967" style="zoom:67%;" />

### 备注

其实我的测试用例选择非常取巧，用到了一个黑白的位图。这样将导致有大量重复的字节。所以结果也非常可观。但是实际上，但凡这是张`png`，结果都差得很，甚至数据会膨胀。

<img src="D:\Project\document\C语言程序设计\报告\image-20200603232438862.png" alt="image-20200603232438862" style="zoom:67%;" />

<img src="D:\Project\document\C语言程序设计\报告\image-20200603232519359.png" alt="image-20200603232519359" style="zoom:67%;" />



这并不奇怪，png是一种压缩文件，可能会改变原有的数据组织方式。另外，单纯对于位图来说，我们是以字节为单位进行处理，如果改成以像素为单位，那么在处理复杂位图的时候效果可能会好一些。





# 六、图书馆管理系统

## 1、题目描述

模拟图书馆管理系统，用户分为图书馆和读者。读者菜单包括借书、还书、查询等功能。管理员菜单包括图书和读者信息录入、修改和删除。图书信息至少应包括：编号、书名、数量，读者信息至少应包括：编号、姓名、所借图书。可根据图书名称或编号进行图书信息查询，可查询某本书现在被哪些读者借走。



## 2、算法描述

行为主体划分，我们有**普通用户**，**管理员**和**图书**。管理员只有一个，而普通用户和图书可以有多个。

由于管理员并不会借书等，我们只需写一些管理员要用到的函数，比如增删改查图书、用户什么的，并不用对其进行数据的储存。

下面考虑如下问题：

1. **如何存储图书和普通用户的信息**
   在程序内用链表储存。原因是两方面的。一方面，链表可以动态分配内存，而数组如果要实现动态代价较大。另一方面，由于用户信息和图书信息难以直接与数组下标对应，所以链表和数组查找效率实际上都是$O(n)$，而链表的删除为$O(1)$，占绝对优势。

2. **图书和用户信息都有什么**

   ```c
   typedef struct {
       int id;         // id，唯一标识符
       char* name;     // 书名
       char* author;   // 作者
       char* press;    // 出版社
       float price;    // 价格
       int num;        // 数量
       int brnum;      // 借出的数量
       int stus[128];  // 借书的人，储存id
   }Book;
   typedef struct {
       int id;
       char* name;		// 名字
       char* pw;		// 登录密码
       int num; 		// 已经借书的数量
       int books[5]; 	// 每个人能借5本书，储存id
   }Student;
   ```

   这里我们借书的信息记录都是记录的`id`，好处就是方便，而且方便存到文件里。为此，我们还要写两个函数，用于通过`id`找到相应的`Book`或者`Student`。

   ```c
   Book* findBookById(int id);
   Student* findStuById(int id);
   ```

   

3. **链表**
   我们有对用户和书对应的链表结点结构体，如下：

   ```c
   // 储存书的链表结点
   typedef struct BookNode{
       Book* x; 
       struct BookNode* bef;
   }BookNode;
   // 储存用户的链表结点
   typedef struct StuNode{
       Student* x;
       struct StuNode* bef;
   }StuNode;
   ```

   链表的初始化为：

   ```c
   // 初始化链表
   inline void chainInit(){
       book_now = (BookNode*) malloc(sizeof(BookNode));
       stu_now = (StuNode*) malloc(sizeof(StuNode));
       
       book_now->x = NULL;
       book_now->bef = book_now;
   
       stu_now->x = NULL;
       stu_now->bef = stu_now;
   }
   ```

   在这种情况下，`node->bef == node`为链表结束的条件。一般遍历链表的形式为：

   ```c
   Node* node = now;
   while(node->bef != node){
       /*code*/
       node = node->bef;
   }
   ```

   这一形式将在程序中被广泛应用。

   

4. **文件储存**
   写两个函数，一个用于从文件读取信息初始化图书链表和用户链表，另一个是遍历图书链表和用户链表并写入文件。

   ```c
   // 从文件读入初始信息
   void fileInit();
   //  文件保存
   void fileWrite();
   ```

   注意我们每次是读取所有的信息，或者写入所有的信息。理论上对于每次的借书、添加书等操作都要对文件内容进行精细化的操作，但是具体实现很麻烦，尤其是删除操作，要定位光标。所以我们是对一个用户的所有操作完成后，统一全部重写文件。

   我们一本书的信息量最多差不多`1kb`，以目前处理器的速度读写`10万`本书差不多一秒钟时间，完全可以接受。

   

5. **如何实现多用户**
   实现`login`方法，返回一个指向某一用户的的指针，表示为当前用户。我们可以使用`id`和`password`来进行校验。

6. **用户的增删改查**
   出去人机交互，本质上都是对链表操作。举个例子：

   ```c
   // 添加书————逻辑页面
   void _addBook(Book* book){
       BookNode *bn = book_now;
       while (bn->bef != bn){
           if (bn->x->id == book->id){
               bn->x->num += book->num;
               return;
           }
           bn = bn->bef;
       }
       bn = (BookNode*) malloc(sizeof(BookNode));
       bn->x = book;
       bn->bef = book_now;
       book_now = bn;
   }
   ```

   如果已经存在了 这种书，则直接进行数量相加。

   其余部分就是一般地链表操作。

   所以这一部分虽然是程序的主体，但是其本质逻辑并不复杂，再次不做更深表述。

7. **人机交互**
   我设置了三个主要的菜单页面：主页面，管理员页面，用户页面。主页面选择身份，然后进行身份验证进入管理员或者用户页面。

   ![image-20200609233523023](%E6%8A%A5%E5%91%8A.assets/image-20200609233523023.png)

   在对应的页面用户和管理员可以看到其可以可以进行的操作。

   <img src="D:\Project\document\C语言程序设计\报告\image-20200609233554151.png" alt="image-20200609233554151" style="zoom:67%;" />

<img src="D:\Project\document\C语言程序设计\报告\image-20200609233615205.png" alt="image-20200609233615205" style="zoom:67%;" />

​			我们为每种操作编写其对应的人机交互逻辑就可以了，其实最后本质上仍然是增删改查。

## 3、源程序

```c
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<stdlib.h>
#include<conio.h>
const int END = -1;

int max(int x, int y){
    if (x > y) return x;
    return y;
}

/*---------------------- 结构体定义 ----------------------*/

// 书
typedef struct {
    int id;         // id，唯一标识符
    char* name;     // 书名
    char* author;   // 作者
    char* press;    // 出版社
    float price;    // 价格
    int num;        // 数量
    int brnum;      // 借出的数量
    int stus[128];  // 借书的人
}Book;

// 储存书的链表结点
typedef struct BookNode{
    Book* x; 
    struct BookNode* bef;
}BookNode;

// 用户
typedef struct {
    int id;
    char* name;
    char* pw;
    int num; // 已经借书的数量
    int books[5]; // 每个人只能借5本书
}Student;

// 储存用户的链表结点
typedef struct StuNode{
    Student* x;
    struct StuNode* bef;
}StuNode;

/*---------------------- 结构体定义 ----------------------*/


/*---------------------- 函数声明 ----------------------*/
void chainInit();
void fileInString(FILE* in, char** tar, char* buf);
inline void stdinString(char** tar, char* buf, char* hint);
void addBook();
void _addBook(Book* book);
int _deleteBook(int id);
void printBook(Book* book);
void checkBooks(BookNode* bn);
Book* findBookById(int id);
int _addStudent(Student* stu);
void addStudent();
int _deleteStudent(int id);
void printStudent(Student* stu);
void checkStudent(StuNode* sn);
Student* findStuById(int id);
Book* getBook();
/*---------------------- 函数声明 ----------------------*/

BookNode *book_now; // 储存书的链表头
StuNode *stu_now; // 储存用户的链表头
int stucnt, bookcnt; // 用户/书数量(严格来说并不是，用于产生id)

/*---------------------- 业务逻辑 ----------------------*/
// 初始化链表
inline void chainInit(){
    book_now = (BookNode*) malloc(sizeof(BookNode));
    stu_now = (StuNode*) malloc(sizeof(StuNode));
    
    book_now->x = NULL;
    book_now->bef = book_now;

    stu_now->x = NULL;
    stu_now->bef = stu_now;
}

// 从文件读入初始信息
void fileInit(){
    FILE* in;
    in = fopen("stu.in", "r");
    int id, cnt = 0;
    char* str = (char*) malloc(256);
    fscanf(in, "%d", &id);
    while(id != END){
        Student* stu = (Student*) malloc(sizeof(Student));
        stu->id = id;
        stucnt = max(stucnt, id);

        fileInString(in, &stu->name, str);
        fileInString(in, &stu->pw, str);

        fscanf(in, "%d", &cnt);
        stu->num = cnt;
        for (int i = 0; i < cnt; i++)
            fscanf(in, "%d", &stu->books[i]);
        _addStudent(stu);
        fscanf(in, "%d", &id);
    }
    fclose(in);

    in = fopen("book.in", "r");
    fscanf(in, "%d", &id);
    while (id != END){
        Book* book = (Book*) malloc(sizeof(Book));
        book->id = id;
        bookcnt = max(bookcnt, id);

        fileInString(in, &book->name, str);
        fileInString(in, &book->author, str);
        fileInString(in, &book->press, str);

        fscanf(in, "%f%d%d", &book->price, &book->num, &book->brnum);
        for (int i = 0; i < book->brnum; i++)
            fscanf(in, "%d", &book->stus[i]);
        _addBook(book);
        fscanf(in, "%d", &id);
    }
    free(str);
    fclose(in);
}

//  文件保存
void fileWrite(){
    FILE* out = fopen("stu.in", "w");
    StuNode* sn = stu_now;
    Student* stu;
    while (sn != sn->bef){
        stu = sn->x;
        fprintf(out, "%d %s %s %d ", 
            stu->id, 
            stu->name, 
            stu->pw,
            stu->num);
        for (int i = 0; i < stu->num; i++)
            fprintf(out, "%d ", stu->books[i]);
        fprintf(out, "\n");
        sn = sn->bef;
    }
    fprintf(out, "%d\n", END);
    fclose(out);

    out = fopen("book.in", "w");
    BookNode* bn = book_now;
    Book* book;
    while (bn->bef != bn){
        book = bn->x;
        fprintf(out, "%d %s %s %s %.2f %d %d ", 
            book->id, 
            book->name, 
            book->author, 
            book->press,
            book->price,
            book->num,
            book->brnum);
        for (int i = 0; i < book->brnum; i++)
            fprintf(out, "%d ", book->stus[i]);
        fprintf(out, "\n");
        bn = bn->bef;
    }
    fprintf(out, "%d\n", END);
    fclose(out);
}

// 从文件输入一串字符串，在指定位置分配恰好的空间，并将其复制到指定位置
// in：要输入的文件， tar：目标位置， buf：输入缓存
inline void fileInString(FILE* in, char** tar, char* buf){
    fscanf(in, "%s", buf);
    (*tar) = (char*) malloc(strlen(buf));
    strcpy(*tar, buf); 
}


// 引导用户输入一串字符串，在指定位置分配恰好的空间，并将其复制到指定位置
// tar：目标位置， buf：输入缓存， hint：提示信息
inline void stdinString(char** tar, char* buf, char* hint){
    printf("%s", hint);
    scanf("%s", buf);
    (*tar) = (char*) malloc(strlen(buf));
    strcpy(*tar, buf); 
}

// 添加书————逻辑页面
void _addBook(Book* book){
    BookNode *bn = book_now;
    while (bn->bef != bn){
        if (bn->x->id == book->id){
            bn->x->num += book->num;
            return;
        }
        bn = bn->bef;
    }
    bn = (BookNode*) malloc(sizeof(BookNode));
    bn->x = book;
    bn->bef = book_now;
    book_now = bn;
}

// 添加书————交互页面
void addBook(){
    Book *book = (Book*) malloc(sizeof(Book));
    char* str = (char*) malloc(256);

    stdinString(&book->name, str, "name: ");
    stdinString(&book->author, str, "author: ");
    stdinString(&book->press, str, "press: ");
    
    printf("price: ");
    scanf("%f", &book->price);

    printf("num: ");
    scanf("%d", &book->num);

    printf("Sure to add?[y/n] : ");
    char flag;
    fflush(stdin);
    scanf("%c", &flag);
    if (flag == 'y' || flag == 'Y'){
        book->id = ++bookcnt;
        book->brnum = 0;
        _addBook(book);
        printf("Succeed!\n");
    }
    free(str);
}

// 打印一本图书
void printBook(Book* book){
    printf("id : %d, ", book->id);
    printf("name : %s, ", book->name);
    printf("author : %s, ", book->author);
    printf("press : %s, ", book->press);
    printf("price : %.2f, ", book->price);
    printf("num : %d, ", book->num);
    printf("brnum : %d, ", book->brnum);
    printf("borrowed by : {");
    for (int i = 0; i < book->brnum - 1; i++){
        Student* stu = findStuById(book->stus[i]);
        printf("{stu_id=%d, stu_name=%s}, ", stu->id, stu->name);
    }
    if (book->brnum > 0){
        Student* stu = findStuById(book->stus[book->brnum - 1]);
        printf("{stu_id=%d, stu_name=%s}", stu->id, stu->name);
    }
    printf("}.\n");
}

// 查询改结点所在链表之前的所有图书
void checkBooks(BookNode* bn){
    while (bn->bef != bn){
        printBook(bn->x);
        bn = bn->bef;
    }
    printf("\n");
}

// 通过id找到在链表的一个用户，并返回指针
Book* findBookById(int id){
    Book* res = NULL;
    BookNode* bn = book_now;
    while (bn->bef != bn){
        if (bn->x->id == id){
            res = bn->x;
            break;
        }
        bn = bn->bef;
    }
    return res;
}

// 通过id找到在链表中找到一本书，并返回指针
Student* findStuById(int id){
    Student* res = NULL;
    StuNode* sn = stu_now;
    while (sn->bef != sn){
        if (sn->x->id == id){
            res = sn->x;
            break;
        }
        sn = sn->bef;
    }
    return res;
}

// 添加一个用户————逻辑页面
int _addStudent(Student* stu){
    StuNode *sn = stu_now;
    while (sn->bef != sn){
        if (sn->x->id == stu->id)
            return -1;
        sn = sn->bef;
    }
    sn = (StuNode*) malloc(sizeof(StuNode));
    sn->x = stu;
    sn->bef = stu_now;
    stu_now = sn;
    return 0;
}

// 添加一个用户————交互页面
void addStudent(){
    Student *stu = (Student*) malloc(sizeof(Student));
    stu->num = 0;
    char* str = (char*) malloc(256);

    stdinString(&stu->name, str, "name: ");
    stdinString(&stu->pw, str, "password: ");

    printf("Sure to add?[y/n] : ");
    char flag;
    fflush(stdin);
    scanf("%c", &flag);
    if (flag == 'y' || flag == 'Y'){
        stu->id = ++stucnt;
        flag = _addStudent(stu);
        if (flag == 0) printf("Succeed!\n");
        else printf("ERROR : The student whose id is %d is existed.\n", stu->id);   
    }
    free(str);
}

// 更改一个用户的信息
void changeStudent(){
    int id;
    printf("Please input id: ");
    scanf("%d", &id);
    Student* stu = findStuById(id);
    if (stu == NULL){
        printf("ERROR: The student (id: %d) is not FOUND!", id);
        return;
    }
    printf("Old information:\n");
    printStudent(stu);
    char* str = (char*) malloc(256);
    stdinString(&stu->name, str, "new name: ");
    stdinString(&stu->pw, str, "new password: ");
    free(str);
    printf("Succeed!\n");
}

// 更改一本书的信息
void changeBook(){
    Book* book = getBook();
    if(book == NULL) return;
    printf("Old information:\n");
    printBook(book);
    char* str = (char*) malloc(256);
    stdinString(&book->name, str, "new name: ");
    stdinString(&book->author, str, "new author: ");
    stdinString(&book->press, str, "new press: ");
    printf("new price: ");
    scanf("%f", &book->price);
    free(str);
    printf("Succeed!\n");
}

// 删除一个用户————逻辑页面
int _deleteStudent(int id){
    StuNode* sn = stu_now;
    if (sn->x->id == id){
        if (sn->x->num > 0) // 如果仍有未还的书，返回-2
            return -2;
        stu_now = sn->bef;
        free(sn);
        return 0;
    }
    StuNode* t = sn->bef;
    while (t->bef != t){
        if (t->x->id == id){
            if (sn->x->num > 0)
                return -2;
            sn->bef = t->bef;
            free(t);
            return 0;
        }
        sn = t;
        t = t->bef;
    }
    // 用户未找到，返回-1
    return -1;
}

// 删除一个用户————交互页面
void deleteStudent(){
    system("cls");
    int id, x;
    printf("Please input id of the student.\nid: ");
    scanf("%d", &id);
    x = _deleteStudent(id);
    if (x == -1)
        printf("ERROR: The student (id: %d) is not FOUND!", id);
    else if (x == -2)
        printf("ERROR: The student (id: %d) has still borrowed some books!", id);
    else printf("Succeed!");
}

// 删除一本书————逻辑页面
int _deleteBook(int id){
    BookNode* bn = book_now;
    if (bn->x->id == id){
        if(bn->x->brnum > 0)
            return -2;      // 还有人借这本书
        book_now = bn->bef;
        free(bn);
        return 0;
    }
    BookNode* t = bn->bef;
    while (t->bef != t){
        if (t->x->id == id){
            if(bn->x->brnum > 0)
                return -2;
            bn->bef = t->bef;
            free(t);
            return 0;
        }
        bn = t;
        t = t->bef;
    }
    // 没找到
    return -1;
}

// 删除一本书————交互页面
void deleteBook(){
    system("cls");
    int id, x;
    printf("Please input id of the book.\nid: ");
    scanf("%d", &id);
    x = _deleteBook(id);
    if (x == -1)
        printf("ERROR: The book (id: %d) is not FOUND!", id);
    else if (x == -2)
        printf("ERROR: Somebody has still borrowed the book (id: %d)!", id);
    else printf("Succeed!");
    
}

// 输出给定用户的信息
void printStudent(Student* stu){
    printf("id : %d, ", stu->id);
    printf("name : %s, ", stu->name);
    printf("borrowed book : {");
    for (int i = 0; i < stu->num - 1; i++){
        Book* book = findBookById(stu->books[i]);
        printf("{book_id=%d, book_name=%s}, ", book->id, book->name);
    }
    if (stu->num > 0){
       Book* book = findBookById(stu->books[stu->num - 1]);
        printf("{book_id=%d, book_name=%s}", book->id, book->name);
    }
    printf("}.\n");
}

// 输出所有的用户信息
void checkStudent(StuNode* sn){
    while (sn->bef != sn){
        printStudent(sn->x);
        sn = sn->bef;
    }
    printf("\n");
}

// 引导用户输入id并尝试寻找到该书，并返回该书
Book* getBook(){
    system("cls");
    int id;
    printf("Book id: ");
    scanf("%d", &id);
    Book* book = findBookById(id);
    if (book == NULL){
        printf("ERROR: The book (id: %d) doesn't exist!\n", id);
        return NULL;
    }
    return book;
}

// 借书————逻辑页面
int _borrowBook(Student* stu, Book* book){
    if (book->brnum >= book->num) return -1; // 书没有了
    if (stu->num >= 5) return -2;      // 学生借书超过限制
    // 在各自的借书/被借列表加上书/人
    stu->books[stu->num++] = book->id;
    book->stus[book->brnum++] = stu->id;
    return 0;
}

// 借书————交互页面
void borrowBook(Student* stu){
    Book* book = getBook();
    if (book == NULL) return;
    
    int x = _borrowBook(stu, book);
    if (x == -1)
        printf("ERROR: No more the book (id: %d)!\n", book->id);
    else if (x == -2)
        printf("ERROR: You've borrowed enough books!\n");
    else printf("Succeed!\n");
}

// 还书————逻辑页面
int _returnBook(Student* stu, Book* book){
    int x = 0, y = 0;

    // 在各自的借书/被借列表找到这本书/这个人
    while (x < stu->num && stu->books[x] != book->id) x++;
    while (y < book->brnum && book->stus[y] != stu->id) y++;
    if (x >= stu->num || y >= book->brnum) return -1; // 学生并没有借这本书

    // 在各自的借书/被借列表删除这本书/这个人
    --stu->num;
    while (x < stu->num) stu->books[x] = stu->books[x + 1], x++;
    --book->brnum;
    while (y < book->brnum) book->stus[y] = book->stus[y + 1], y++;
    return 0;
}

// 还书————交互页面
void returnBook(Student* stu){
    Book* book = getBook();
    if (book == NULL) return; // 要还的书不存在

    int x = _returnBook(stu, book);
    if (x == -1) // 还书失败
        printf("ERROR: You haven't borrowed the book(id: %d)!\n", book->id);
    else printf("Succeed!\n");
}

/*---------------------- 业务逻辑 ----------------------*/


/*-------------------------界面控制------------------------*/

// 初始化
void init(){
    chainInit();
    fileInit();
}

// 学生登录
Student* login(){
    Student* res = NULL;
    int id;
    char pw[256];
    printf("User ID : ");
    scanf("%d", &id);
    res = findStuById(id);
    if (res == NULL) return res;
    system("cls");
    printf("Username: %s\n", res->name);
    printf("PassWord: ");
    scanf("%s", pw);
    if (strcmp(pw, res->pw) == 0)
        return res;
    return NULL;
}

// 主界面
void mainUI(){
    system("cls");
    printf("----------------- XDU BMS -----------------\n");
    printf("copyright@Rain Chen\n");
    printf("Selection menu:\n");
    printf("1 For student login.\n");
    printf("2 For admin login.\n");
    printf("q For quit.\n");
}

// 用户界面
void userUI(char* str){
    system("cls");
    printf("------------------- Welecome %s! -------------------\n", str);
    printf("Selection menu:\n");
    printf("1 To check your status.\n");
    printf("2 To check all valid books.\n");
    printf("3 To borrow a book.\n");
    printf("4 To return a book.\n");
    printf("q To exit.\n");
    printf("------------------------------------------------------\n");
}

// 用户的操作逻辑控制
void forStu(){
    // 登录
    Student* stu = login();
    if (stu == NULL){
        printf("ERROR: Invalid accout or password!\n");
        system("pause");
        return;
    }

    int x, flag = 1;
    userUI(stu->name);
    while (flag){
        x = _getch();
        userUI(stu->name);
        if (x == 49) printStudent(stu);
        if (x == 50) checkBooks(book_now);
        if (x == 51) borrowBook(stu);
        if (x == 52) returnBook(stu);
        if (x == 113) flag = 0;
    }  
}

// 管理员界面
void adminUI(){
    system("cls");
    printf("-------------------ADMIN-------------------\n");
    printf("Selection menu:\n");
    printf("1 To check all user's status.\n");
    printf("2 To check all valid books.\n");
    printf("3 To add some new books.\n");
    printf("4 To remove some books.\n");
    printf("5 To add new user.\n");
    printf("6 To remove user.\n");
    printf("7 To change student information.\n");
    printf("8 To change book information\n");
    printf("q To exit.\n");
    printf("-------------------------------------------\n");
}

// 管理员的操作逻辑控制
void forAdmin(){
    char str[256];
    // 密码校验
    printf("password: ");
    scanf("%s", str);
    if (strcmp(str, "admin") != 0){
        printf("Invalid password!\n");
        system("pause");
        return;
    }

    int x, flag = 1;
    adminUI();
    while (flag){
        x = _getch();
        adminUI();
        if (x == 49) checkStudent(stu_now);
        if (x == 50) checkBooks(book_now);
        if (x == 51) addBook();
        if (x == 52) deleteBook();
        if (x == 53) addStudent();
        if (x == 54) deleteStudent();
        if (x == 55) changeStudent();
        if (x == 56) changeBook();        
        if (x == 113) flag = 0;
    }  
}

// 主页面的操作逻辑控制
int main(){
    init();
    // system("pause");
    int x;
    while (1){
        mainUI();
        x = _getch();
        fflush(stdin);
        if (x == 113) break;    // 113 对应键盘按键"q"
        if (x == 49) forStu(); // 49 对应键盘按键"1"
        if (x == 50) forAdmin(); // 50 对应键盘按键"2"，其他数字以此类推
        fileWrite();
    }

    system("cls");
    printf("Goodbye~~~\n");
    system("pause");
    return 0;
}

```



## 4、测试

现场演示。附视频在同一文件夹。

<img src="D:\Project\document\C语言程序设计\报告\image-20200610181649557.png" alt="image-20200610181649557" style="zoom: 50%;" />

<img src="D:\Project\document\C语言程序设计\报告\image-20200610181712070.png" alt="image-20200610181712070" style="zoom:50%;" />

<img src="D:\Project\document\C语言程序设计\报告\image-20200610181750904.png" alt="image-20200610181750904" style="zoom:50%;" />

# 7、小结

之前没没有用C写过这么多代码。收获很大，发现了指针的用处。指针原来是这么有用的一个东西，而且用指针的感觉和对JAVA对象操作的感觉。也愈发觉得JAVA中的引用对象为封装好的指针。

学习了一些算法，比如位图缩放还有RLE，这些算法原理都很简单，但是实现起来还真是不那么容易。也很开心最后自己都做出来了。以后也要切记不要眼高手低。

图书馆因为在JAVA上机练习中写过，我原以为会比较简单。但是我发现C和JAVA设计基本上不是一个逻辑。当然也有很多地方是相同的，比如内部实现逻辑和用户交互分离开来。这样有助与程序复用并且逻辑清晰，易于`debug`。

不管怎么说，再接再厉。